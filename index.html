<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>az: Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">az
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Overview </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2home_2runner_2work_2az_2az_2README"></a>Az is a runtime type system and class library for C</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Features</h1>
<p>Provides a way to manage full runtime type system for both C builtin types and arbitrary composite types (C structs).</p>
<ul>
<li>construction and destruction</li>
<li>inheritance</li>
<li>polymorphism</li>
<li>multiple inheritance (Java style interfaces)</li>
<li>reflection</li>
</ul>
<p>It also implements a set of convenient types</p>
<ul>
<li>references</li>
<li>objects</li>
<li>active objects (with signaling and attributes)</li>
<li>collection interfaces</li>
<li>function interface</li>
</ul>
<p>By default it is compiled as a drop-in static library.</p>
<p><a href="https://lauris71.github.io/az/">The Doxygen-generated documentation</a></p>
<h1><a class="anchor" id="autotoc_md2"></a>
Building</h1>
<p>It needs arikkei for some low-level string methods. Just clone <a href="https://github.com/lauris71/arikkei">arikkei</a> to an accessible place (either to the root of your main project or to the root of az project directory). Then, in the az project directory execute: </p><pre class="fragment">cmake -S . -B build
cmake --build build
</pre> <h1><a class="anchor" id="autotoc_md3"></a>
Motivation</h1>
<h2><a class="anchor" id="autotoc_md4"></a>
Frustration with C++</h2>
<ol type="1">
<li>No unified ABI. Overloading virtual method dispatch would help a lot, but this is not possible</li>
<li>No standardized RTTI. Especially no RTTI for primitive types</li>
<li>Ugly and bloated syntax, especially if std::* is used</li>
<li>No clean POD syntax (struct should have been forced POD)</li>
<li>No manual aliasing of name mangling</li>
<li>Braindead multiple inheritance (Java got it almost right with object/interface)</li>
</ol>
<h2><a class="anchor" id="autotoc_md5"></a>
Frustration with Glib</h2>
<ol type="1">
<li>For some reason it is not drop’n’build</li>
<li>Gobject is too complex/opaque with signals etc.</li>
<li>No RTTI for primitive types</li>
</ol>
<h1><a class="anchor" id="autotoc_md6"></a>
Fundamental ideas</h1>
<p>The building blocks of az are:</p><ul>
<li>instance</li>
<li>value</li>
<li>class</li>
<li>implementation</li>
</ul>
<h2><a class="anchor" id="autotoc_md7"></a>
Instance</h2>
<p>Instance is the actual data. Each instance is just some number of bits somewhere in memory.</p>
<p>These bits may be unique (for block types) or copied around (value types) during execution.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Value</h2>
<p>Value is the "handle" of instance data visible to library.</p>
<p>For value types this is the instance itself (i.e. if instance A contains an instance of a value type B, then A actually contains all the bits of B).</p>
<p>For block types the value is pointer to instance (i.e. if instance A contains an instance of a block type B, then A only contains pointer, the bits of B reside somewhere else).</p>
<p>We use the term "block" because "reference" is a specific subtype (implements reference counting) of the block.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Implementation and class</h2>
<p>For plain (non-interface) types these are the same.</p>
<p>Implementation contains polymorphic parts of static data (commonly virtual methods, but nothing forbids them to have virtual data fields also). One can think about implementation as the definiton "how these bits of instance behave".</p>
<p>Class contains the type definition of data "what these bits of instance are".</p>
<p>All classes are itself implementations (thus they can contain virtual methods and virtual data). For standalone instances this is all the polymorphism needed. But for interfaces the distinction is important.</p>
<p>Interfaces are implemented (in different ways) inside other instances. All implementations of the same interface have the same base type information (class), and thus part of their polymorphic data has to be specified by the implementations. Normally this is done by embedding the implementation of an interface type inside the implementation (or class) of the containing type.</p>
<p>Which virtual methods of an interface belong to the class and which to the implementation depends on the semantics of the interface and methods.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Basic type hierachy</h1>
<blockquote class="doxtable">
<p>&zwj;Any</p><ul>
<li>Value types (there is no common value superclass)</li>
<li>Block<ul>
<li>Implementation<ul>
<li>Class</li>
</ul>
</li>
<li>Interface</li>
<li>Reference<ul>
<li>Boxed value</li>
<li>Boxed interface</li>
<li>String</li>
<li>Object </li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h1><a class="anchor" id="autotoc_md11"></a>
Special data types</h1>
<ul>
<li>Boxed value</li>
<li>Boxed interface</li>
<li>Object</li>
</ul>
<h2><a class="anchor" id="autotoc_md12"></a>
Boxed value</h2>
<p>Boxed value contains the type (i.e. a pointer to the implementation) and the instance (i.e. the actual bits) of a value type inside of a reference (i.e. a block type) wrapper.</p>
<p>It is needed to retrieve a value of unknown size (e.g. reading a property with "Any" type), or to store a value type of arbitrary size inside inside containers with fixed element size.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Boxed interface</h2>
<p>Boxed interface contains value (i.e. pointer to the implementation and the value) of an instance and an interface (i.e. pointer to the implementation and pointer to the instance) implemented in the former.</p>
<p>Interfaces are "owned" by the containing instance. Thus methods cannot extend the lifecycle of an interface beyond the duration of the containing instance. But in many situations one may want to extend it – e.g. to create a collection of interfaces.</p>
<p>Unless the external application logic dictates that the interfaces remain valid during the existence of such collection, boxed interface can be used instead. Boxed interface contains the value of owner and thus also the interface of interest. The interface is directly accessible (does not need to be queried if the instance type layout is not familiar to the caller).</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Object</h2>
<p>Object is a special reference type that "knows" it’s class (i.e. has a pointer to the class inside instance). Thus, unlike other non-final types, objects can be accessed simply by instance without the need to specify the implementation.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Specifying instances</h1>
<p>All classes are assigned integer type values. These integer values can be used instead of class pointers to specify a type.</p>
<p>All implementations either are classes, or contain class pointer as the first element. Thus class can always be obtained from an implementation.</p>
<p>Data is generally accessed by specifying its implementation and instance or implementation and value. </p><pre class="fragment">my_type_do_something(const AZImplementation *impl, void *inst);
my_type_do_something_else(const AZImplementation *impl, AZValue *val);
</pre><p> To perform some action with a type, the first method (instance) is usually more convenient. The latter is commonly used for polymorphic collections (instances of block types cannot be put into collections).</p>
<p>To retreve polymorphic data, both implementaton and value has to be retrieved (the destination has to be value because instances of block types normally can neither be copied nor created in stack). </p><pre class="fragment">AZImplementation *impl = az_parse_type(const uint8_t *buf, AZValue *val);
</pre><p> For final types and objects the implementation pointer is usually omitted in methods because for those it either is fixed or can be derived from the instance</p>
<p>Methods that do not use polymorphic parts of data also often omit the implementation pointer.</p>
<h1><a class="anchor" id="autotoc_md16"></a>
Some notes</h1>
<p>Polymorphism in C means that there are strict limits to both compile-time and run-time type safety. But imo type safety is currently much overhyped. If you need compile-time type safety to protect yourself against bugs you have much bigger problems and probably should not write complex code at all.</p>
<p>Objects provide run-time type safety but this is not free. For more primitive types one has to rely on good programming practice (clean structure, clean naming conventions etc.)</p>
<p>Creating reflexive types involves writing non-trivial amount of boilerplate code (writing class structure, class and instance initializers, field specifications and so on.) Imo it is worth it. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Feb 2 2026 16:02:43 for az by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
